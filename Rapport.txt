Rapport du projet


Notre équipe, constituée de Hugo, Alexis et Ismail, a opté pour le projet CER-J-O en raison de l'approche imminente des Jeux Olympiques, un événement qui a captivé notre attention. De plus, à travers ce projet nous avons pu renforcer et enrichir notre maîtrise des fichiers, des structures mais aussi des tableaux. Ainsi, nous avons développé un programme robuste qui permet à un entraîneur de sélectionner les activités en fonction des athlètes à sa disposition. De plus, nos fonctions statistiques lui permettent d'évaluer les performances de ses sportifs.


Tout d’abord, afin de pouvoir gérer les épreuves, nous avons instantanément eu l’idée de créer une énumération pour rendre le code plus flexible, ce qui nous a permis par la suite d’ajouter des épreuves.

Ensuite, pour créer un fichier par personne, nous avons conçu une structure nommée "Sportif" ainsi qu'une procédure appelée "CreerFichier", qui demande à l'entraîneur le nombre d'athlètes et génère ensuite un fichier pour chacun, en attribuant un nom à chaque athlète et enregistrant son âge en fonction du nombre fourni. Nous avons par la suite décidé de retirer l’âge du programme afin de nous concentrer sur le cahier des charges avant tout.

Malgré cette approche ingénieuse,  nous avons rencontré un obstacle lorsque Alexis a nécessité l'utilisation d'un tableau de fichiers afin de les parcourir pour chaque affichage. Pour résoudre ce problème, il a décidé de créer simplement un tableau contenant les noms de tous les athlètes, afin de pouvoir ouvrir chaque fichier à l’aide du prénom de l’athlète. Pour ce faire, nous avons adapté la fonction "CreerFichier" et toutes les autres fonctions d’affichage pour qu'elles acceptent en paramètre le nombre d'athlètes et leur nom. Cette modification nous a permis de parcourir les athlètes de manière itérative, en conservant les données individuelles de chacun, à l'exception de l'âge.	

Par la suite, l’ajout d’un entraînement par ligne dans un fichier, s’est effectué en introduisant une structure nommée “Entraînement” qui prend en compte la structure “Sportif” pour identifier l'athlète concerné et comprend également deux nouvelles structures “Date” et “Temps” pour enregistrer la date et l'heure de l'entraînement.
La conception de la procédure "AjouterEntrainement" a initialement posé des défis, nécessitant une réflexion prolongée sur la meilleure approche à adopter. Cependant, lors d'un cours d'informatique, nous avons sollicité l'aide d'Eva Ansermin pour éclaircir certains aspects, notamment la conception du relais. Par la suite, Ismail a consacré plusieurs jours à concrétiser ses idées et à finaliser la fonction. Ensuite, Hugo a effectué des vérifications minutieuses pour déceler toute erreur éventuelle. En cas de découverte d'anomalies, nous avons réagi rapidement pour renforcer la robustesse de la fonction, notamment en intégrant la fonction "getchar" vue en cours, ce qui permet d'éviter les boucles infinies en cas de saisie incorrecte de l'utilisateur.

Pour gérer le cas du relais, nous avons intégré cette fonctionnalité simultanément avec la procédure "AjouterEntrainement", étant donné son intégration directe dans cette fonction. Initialement, nous avons configuré l'épreuve pour impliquer quatre athlètes, mais nous avons rapidement réalisé qu'il était possible de sélectionner le même athlète plusieurs fois.  Par conséquent, nous avons dû mettre en place des vérifications pour nous assurer à la fois que les athlètes choisis étaient distincts et qu'aucun d'entre eux n'avait déjà participé ce jour-là. Pour cette dernière vérification, nous avons élaboré une fonction appelée "VerifierDateRelais", que nous avons ensuite intégrée dans une boucle pour garantir qu'aucun athlète n'avait déjà participé ce jour-là (le jour choisi).

Les épreuves bonus qu'on a ajouté ont été simples à faire puisqu'il fallait simplement s'inspirer des épreuves déjà faites. Pour les sports de combat, on a fait en sorte que le vainqueur de chaque combat soit aléatoire. Pour la natation nous avons repris la forme de l’épreuve relais mais avec des choix d’exercice spécifique (crawl, brasse…).

Pour les statistiques, la fonction "pire_temps" a été créée par erreur lorsque Ismail pensait concevoir la fonction "meilleur_temps", en supposant à tort que le meilleur temps serait le plus long. Bien que cette confusion ait initialement entraîné la création de la mauvaise fonction, sa mise en place n'a pas posé de difficultés majeures. Ismail a pu s'appuyer sur les fonctions existantes et s'en inspirer. Cependant, un défi est survenu lors de la première implémentation, où la fonction classait le meilleur temps comme étant le premier, en raison du manque de conditions et de déclarations adéquates. Quant à la fonction "meilleur_temps", son développement a été plus simple. Ismail a simplement copié et collé la fonction "pire_temps", puis a ajusté quelques conditions et déclarations pour obtenir le résultat souhaité. Une fois ces ajustements apportés, la fonction a pu identifier correctement le meilleur temps sans difficulté.
Dans le développement des fonctions “perf_athlete” et “diff_temps”, Hugo a créé un tableau fixe pour stocker les noms des épreuves. Cela permet de simplifier la gestion des épreuves et de faciliter la comparaison des données. En utilisant un tableau fixe, nous pouvons accéder rapidement aux noms des épreuves en utilisant des indices, ce qui rend le code plus clair. De plus, j'ai utilisé la fonction "sscanf" pour récupérer des données à partir d'un fichier texte. J'ai recherché des informations sur internet pour comprendre son fonctionnement, car je ne savais pas initialement comment extraire des données d'un fichier texte. 


En conclusion, la réalisation de ce projet a été une expérience enrichissante où nous avons pris plaisir à coder ensemble et à nous entraider. Nous avons également appris à nous organiser de manière autonome dans le domaine de l'informatique, en permettant à chacun de travailler sur les parties du projet qui l'intéressaient, jusqu'à ce qu'il ait besoin d'assistance ou qu'il ait terminé son travail. Ensuite, nous avons effectué des vérifications et des tests en groupe pour évaluer le fonctionnement et la robustesse de chaque fonction. Cette approche collaborative nous a permis d'apporter des améliorations, de simplifier le code si nécessaire et de renforcer sa fiabilité.
